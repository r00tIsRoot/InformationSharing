# ÏõêÎ¨∏
    
  ## All About PendingIntents

  PendingIntents are an important part of the Android framework, but most of the available developer resources focus on their implementation details ‚Äî a ‚Äúreference to a token maintained by the system‚Äù ‚Äî rather than their usage.

  Since Android 12 includes important changes to pending intents, including a change that requires explicitly deciding when a PendingIntent is mutable or immutable, I thought it would be helpful to talk more what pending intents do, how the system uses them, and why you might occasionally want a mutable PendingIntent.

  ### What is a PendingIntent?
  A PendingIntent object wraps the functionality of an Intent object while allowing your app to specify something that another app should do, on your app‚Äôs behalf, in response to a future action. For example, the wrapped intent might be invoked when an alarm goes off, or when the user taps on a notification.

  A key aspect of pending intents is that another app invokes the intent on your app‚Äôs behalf. That is, the other app uses your app‚Äôs identity when invoking the intent.

  In order for the PendingIntent to have the same behavior as if it were a normal Intent, the system triggers the PendingIntent with the same identity as it was created with. In most situations, such as the alarm and notifications, this is the identity of the app itself.

  Let‚Äôs take a look at the different ways our apps can work with PendingIntents and why we might want to use them in these ways.

  ### Common case
  The most common, and most basic, way to use a PendingIntent is as the action associated with a notification:

  ```kotlin
  val intent = Intent(applicationContext, MainActivity::class.java).apply {
      action = NOTIFICATION_ACTION
      data = deepLink
  }
  val pendingIntent = PendingIntent.getActivity(
      applicationContext,
      NOTIFICATION_REQUEST_CODE,
      intent,
      PendingIntent.FLAG_IMMUTABLE
  )
  val notification = NotificationCompat.Builder(
          applicationContext,
          NOTIFICATION_CHANNEL
      ).apply {
          // ...
          setContentIntent(pendingIntent)
          // ...
      }.build()
  notificationManager.notify(
      NOTIFICATION_TAG,
      NOTIFICATION_ID,
      notification
  )
  ```

  We can see that we‚Äôre constructing a standard type of Intent that will open our app, and then simply wrapping that in a PendingIntent before adding it to our notification.

  In this case, since we have an exact action we know we want to perform, we construct a PendingIntent that cannot be modified by the app we pass it to by utilizing a flag called FLAG_IMMUTABLE.

  After we call NotificationManagerCompat.notify() we‚Äôre done. The system will display the notification, and, when the user clicks on it, call PendingIntent.send() on our PendingIntent, starting our app.

  ### Updating an immutable PendingIntent
  You might think that if an app needs to update a PendingIntent that it needs to be mutable, but that‚Äôs not always the case! The app that creates a PendingIntent can always update it by passing the flag FLAG_UPDATE_CURRENT:

  ```kotlin
  val updatedIntent = Intent(applicationContext, MainActivity::class.java).apply {
     action = NOTIFICATION_ACTION
     data = differentDeepLink
  }
  // Because we're passing `FLAG_UPDATE_CURRENT`, this updates
  // the existing PendingIntent with the changes we made above.
  val updatedPendingIntent = PendingIntent.getActivity(
     applicationContext,
     NOTIFICATION_REQUEST_CODE,
     updatedIntent,
     PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
  )
  // The PendingIntent has been updated.
  ```

  We‚Äôll talk about why one may want to make a PendingIntent mutable in a bit.

  ### Inter-app APIs
  The common case isn‚Äôt only useful for interacting with the system. While it is most common to use startActivityForResult() and onActivityResult() to receive a callback after performing an action, it‚Äôs not the only way.

  Imagine an online ordering app that provides an API to allow apps to integrate with it. It might accept a PendingIntent as an extra of its own Intent that‚Äôs used to start the process of ordering food. The order app only starts the PendingIntent once the order has been delivered.

  In this case the ordering app uses a PendingIntent rather than sending an activity result because it could take a significant amount of time for the order to be delivered, and it doesn‚Äôt make sense to force the user to wait while this is happening.

  We want to create an immutable PendingIntent because we don‚Äôt want the online ordering app to change anything about our Intent. We just want them to send it, exactly as it is, when the order‚Äôs arrived.

  ### Mutable PendingIntents
  But what if we were the developers for the ordering app, and we wanted to add a feature that would allow the user to type a message that would be sent back to the app that called it? Perhaps to allow the calling app to show something like, ‚ÄúIt‚Äôs PIZZA TIME!‚Äù

  The answer to this is to use a mutable PendingIntent.

  Since a PendingIntent is essentially a wrapper around an Intent, one might think that there would be a method called PendingIntent.getIntent() that one could call to get and update the wrapped Intent, but that‚Äôs not the case. So how does it work?

  In addition to the send() method on PendingIntent that doesn‚Äôt take any parameters, there are a few other versions, including this version, which accepts an Intent:

  ```kotlin
  fun PendingIntent.send(
      context: Context!, 
      code: Int, 
      intent: Intent?
  )
  ```

  This intent parameter doesn‚Äôt replace the Intent that‚Äôs contained in the PendingIntent, but rather it is used to fill in parameters from the wrapped Intent that weren‚Äôt provided when the PendingIntent was created.

  Let‚Äôs look at an example.

  ```kotlin
  val orderDeliveredIntent = Intent(applicationContext, OrderDeliveredActivity::class.java).apply {
     action = ACTION_ORDER_DELIVERED
  }
  val mutablePendingIntent = PendingIntent.getActivity(
     applicationContext,
     NOTIFICATION_REQUEST_CODE,
     orderDeliveredIntent,
     PendingIntent.FLAG_MUTABLE
  )
  ```

  This PendingIntent could be handed over to our online order app. After the delivery is completed, the order app could take a customerMessage and send that back as an intent extra like this:

  ```kotlin
  val intentWithExtrasToFill = Intent().apply {
     putExtra(EXTRA_CUSTOMER_MESSAGE, customerMessage)
  }
  mutablePendingIntent.send(
     applicationContext,
     PENDING_INTENT_CODE,
     intentWithExtrasToFill
  )
  ```

  The calling app will then see the extra EXTRA_CUSTOMER_MESSAGE in its Intent and be able to display the message.

  ### Important considerations when declaring pending intent mutability
  ‚ö†Ô∏è When creating a mutable PendingIntent ALWAYS explicitly set the component that will be started in the Intent. This can be done the way we‚Äôve done it above, by explicitly setting the exact class that will receive it, but it can also be done by calling Intent.setComponent().

  Your app might have a use case where it seems easier to call Intent.setPackage(). Be very careful of the possibility to match multiple components if you do this. It‚Äôs better to specify a specific component to receive the Intent if at all possible.

  ‚ö†Ô∏è If you attempt to override the values in a PendingIntent that was created with FLAG_IMMUTABLE will fail silently, delivering the original wrapped Intent unmodified.

  Remember that an app can always update its own PendingIntent, even when they are immutable. The only reason to make a PendingIntent mutable is if another app has to be able to update the wrapped Intent in some way.

  ### Details on flags
  We‚Äôve talked a bit about a few of the flags that can be used when creating a PendingIntent, but there are a few others to cover as well.

  FLAG_IMMUTABLE: Indicates the Intent inside the PendingIntent cannot be modified by other apps that pass an Intent to PendingIntent.send(). An app can always use FLAG_UPDATE_CURRENT to modify its own PendingIntents

  Prior to Android 12, a PendingIntent created without this flag was mutable by default.

  ‚ö†Ô∏è On Android versions prior to Android 6 (API 23), PendingIntents are always mutable.

  üÜï FLAG_MUTABLE: Indicates the Intent inside the PendingIntent should allow its contents to be updated by an app by merging values from the intent parameter of PendingIntent.send().

  ‚ö†Ô∏è Always fill in the ComponentName of the wrapped Intent of any PendingIntent that is mutable. Failing to do so can lead to security vulnerabilities!

  This flag was added in Android 12. Prior to Android 12, any PendingIntents created without the FLAG_IMMUTABLE flag were implicitly mutable.

  FLAG_UPDATE_CURRENT: Requests that the system update the existing PendingIntent with the new extra data, rather than storing a new PendingIntent. If the PendingIntent isn‚Äôt registered, then this one will be.

  FLAG_ONE_SHOT: Only allows the PendingIntent to be sent once (via PendingIntent.send()). This can be important when passing a PendingIntent to another app if the Intent inside it should only be able to be sent a single time. This may be related to convenience, or to prevent the app from performing some action multiple times.

  üîê Utilizing FLAG_ONE_SHOT prevents issues such as ‚Äúreplay attacks‚Äù.

  FLAG_CANCEL_CURRENT: Cancels an existing PendingIntent, if one exists, before registering this new one. This can be important if a particular PendingIntent was sent to one app, and you‚Äôd like to send it to a different app, potentially updating the data. By using FLAG_CANCEL_CURRENT, the first app would no longer be able to call send on it, but the second app would be.

  ### Receiving PendingIntents
  Sometimes the system or other frameworks will provide a PendingIntent as a return from an API call. One example is the method MediaStore.createWriteRequest() that was added in Android 11.

  ```kotlin
  static fun MediaStore.createWriteRequest(
      resolver: ContentResolver, 
      uris: MutableCollection<Uri>
  ): PendingIntent
  ```

  Just as a PendingIntent created by our app is run with our app‚Äôs identity, a PendingIntent created by the system is run with the system‚Äôs identity. In the case of this API, this allows our app to start an Activity that can grant write permission to a collection of Uris to our app.

  ### Summary
  We‚Äôve talked about how a PendingIntent can be thought of as a wrapper around an Intent that allows the system, or another app, to start an Intent that one app created, as that app, at some time in the future.

  We also talked about how a PendingIntents should usually be immutable and that doing so doesn‚Äôt prevent the app from updating its own PendingIntent objects. The way it can do so is by using the FLAG_UPDATE_CURRENT flag in addition to FLAG_IMMUTABLE.

  We‚Äôve also talked about the precautions we should make ‚Äî ensuring to fill in the ComponentName of the wrapped Intent ‚Äî if a PendingIntent is necessary to be mutable.

  Finally, we talked about how sometimes the system, or frameworks, may provide PendingIntents to our app so that we can decide how and when to run them.

  Updates to PendingIntent were just one of the features in Android 12 designed to improve app security. Read about all the changes in the preview here.

  Want to do even more? We encourage you to test your apps on the new developer preview of the OS and provide us feedback on your experiences! 
    
# Î≤àÏó≠

  ## PendingIntentÏóê ÎåÄÌïú Î™®Îì†Í≤É

  PendingIntentÎäî ÏïàÎìúÎ°úÏù¥Îìú ÌîÑÎ†àÏûÑÏõåÌÅ¨Ïùò Ï§ëÏöîÌïú Î∂ÄÎ∂ÑÏù¥ÏßÄÎßå, ÎåÄÎ∂ÄÎ∂ÑÏùò Í∞úÎ∞ú Î¶¨ÏÜåÏä§Îäî Íµ¨ÌòÑ ÏÑ∏Î∂Ä ÏÇ¨Ìï≠Ïù∏ "ÏãúÏä§ÌÖúÏóêÏÑú Ïú†ÏßÄÌïòÎäî ÌÜ†ÌÅ∞Ïóê ÎåÄÌïú Ï∞∏Ï°∞"Ïóê ÎåÄÌï¥ Îã§Î£®Í≥† ÏûàÏúºÎ©∞, ÏÇ¨Ïö©Î≤ïÏóê ÎåÄÌï¥ÏÑúÎäî Ïûò Îã§Î£®ÏßÄ ÏïäÏäµÎãàÎã§.

  ÏïàÎìúÎ°úÏù¥Îìú 12ÏóêÏÑúÎäî ÎØ∏Îûò ÏûëÏóÖÏóê ÎåÄÌïú PendingIntentÍ∞Ä Í∞ÄÎ≥Ä(mutability) ÎòêÎäî Î∂àÎ≥Ä(immutable)Ïù∏ÏßÄ Î™ÖÏãúÏ†ÅÏúºÎ°ú Í≤∞Ï†ïÌï¥Ïïº ÌïòÎäî Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ÏùÑ Ìè¨Ìï®ÌïòÏó¨ PendingIntentÏóê Ï§ëÏöîÌïú Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê, PendingIntentÍ∞Ä ÌïòÎäî Ïùº, ÏãúÏä§ÌÖúÏóêÏÑú Ïñ¥ÎñªÍ≤å ÏÇ¨Ïö©ÎêòÎäîÏßÄ, Í∞ÄÎÅî Í∞ÄÎ≥Ä PendingIntentÍ∞Ä ÌïÑÏöîÌïú Ïù¥Ïú†Ïóê ÎåÄÌï¥ Îçî ÏûêÏÑ∏Ìûà Ïù¥ÏïºÍ∏∞ÌïòÍ≥†Ïûê Ìï©ÎãàÎã§.

  ### PendingIntentÎûÄ?
  PendingIntent Í∞ùÏ≤¥Îäî Intent Í∞ùÏ≤¥Ïùò Í∏∞Îä•ÏùÑ ÎûòÌïëÌïòÎ©¥ÏÑú Ïï±Ïù¥ Îã§Î•∏ Ïï±Ïù¥ ÌäπÏ†ï ÎèôÏûëÏùÑ ÏàòÌñâÌïòÎèÑÎ°ù ÏöîÏ≤≠Ìï† Ïàò ÏûàÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§. ÏòàÎ•º Îì§Ïñ¥, Í∞êÏÜåÍ∏∞Í∞Ä Ïö∏Î¶¥ Îïå ÎòêÎäî ÏÇ¨Ïö©ÏûêÍ∞Ä ÏïåÎ¶ºÏùÑ ÌÉ≠Ìï† Îïå ÎûòÌïëÎêú IntentÍ∞Ä Ìò∏Ï∂úÎê† Ïàò ÏûàÏäµÎãàÎã§.

  PendingIntentÏùò ÌïµÏã¨Ï†ÅÏù∏ Ï∏°Î©¥ÏùÄ Îã§Î•∏ Ïï±Ïù¥ IntentÎ•º Ìò∏Ï∂úÌï† Îïå Ïï±Ïùò ÎåÄÏã†Ïóê Ïï±Ïùò ÏãùÎ≥Ñ Ï†ïÎ≥¥Î•º ÏÇ¨Ïö©ÌïúÎã§Îäî Í≤ÉÏûÖÎãàÎã§.

  PendingIntentÍ∞Ä ÏùºÎ∞òÏ†ÅÏù∏ IntentÏôÄ ÎèôÏùºÌïú ÎèôÏûëÏùÑ Í∞ÄÏ†∏Ïïº ÌïúÎã§Î©¥, ÏãúÏä§ÌÖúÏùÄ PendingIntentÎ•º ÏÉùÏÑ±Ìï† ÎïåÏôÄ ÎèôÏùºÌïú ÏãùÎ≥Ñ Ï†ïÎ≥¥Î°ú PendingIntentÎ•º Ìä∏Î¶¨Í±∞Ìï©ÎãàÎã§. ÎåÄÎ∂ÄÎ∂ÑÏùò Í≤ΩÏö∞, ÏïåÎûå Î∞è ÏïåÎ¶ºÍ≥º Í∞ôÏùÄ Í≤ΩÏö∞ÏóêÎäî Ïï± ÏûêÏ≤¥Ïùò ÏãùÎ≥Ñ Ï†ïÎ≥¥ÏûÖÎãàÎã§.

  PendingIntentÎ•º ÏÇ¨Ïö©ÌïòÎäî Îã§ÏñëÌïú Î∞©Î≤ïÍ≥º Í∑∏ Î∞©ÏãùÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Îäî Ïù¥Ïú†Ïóê ÎåÄÌï¥ ÏïåÏïÑÎ≥¥Í≤†ÏäµÎãàÎã§.

  ### ÏùºÎ∞òÏ†ÅÏù∏ Í≤ΩÏö∞
  Í∞ÄÏû• ÏùºÎ∞òÏ†ÅÏù¥Í≥† Í∏∞Î≥∏Ï†ÅÏù∏ Î∞©Î≤ïÏùÄ PendingIntentÎ•º ÏïåÎ¶ºÍ≥º Í¥ÄÎ†®Îêú ÎèôÏûëÏúºÎ°ú ÏÇ¨Ïö©ÌïòÎäî Í≤ÉÏûÖÎãàÎã§.

  ```kotlin
  val intent = Intent(applicationContext, MainActivity::class.java).apply {
      action = NOTIFICATION_ACTION
      data = deepLink
  }
  val pendingIntent = PendingIntent.getActivity(
      applicationContext,
      NOTIFICATION_REQUEST_CODE,
      intent,
      PendingIntent.FLAG_IMMUTABLE
  )
  val notification = NotificationCompat.Builder(
          applicationContext,
          NOTIFICATION_CHANNEL
      ).apply {
          // ...
          setContentIntent(pendingIntent)
          // ...
      }.build()
  notificationManager.notify(
      NOTIFICATION_TAG,
      NOTIFICATION_ID,
      notification
  )
  ```

  Ïö∞Î¶¨Îäî Ïï±ÏùÑ Ïó¥ IntentÎ•º ÎßåÎì§Í≥†, Í∑∏Í≤ÉÏùÑ PendingIntentÎ°ú Í∞êÏã∏ ÏïåÎ¶ºÏóê Ï∂îÍ∞ÄÌïòÍ∏∞Îßå ÌïòÎ©¥ Îê©ÎãàÎã§.

  Ïù¥ Í≤ΩÏö∞, ÏàòÌñâÌï† ÌäπÏ†ïÌïú ÎèôÏûëÏù¥ ÏûàÏúºÎØÄÎ°ú, FLAG_IMMUTABLEÏù¥ÎùºÎäî ÌîåÎûòÍ∑∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ïï±Ïù¥ Ï†ÑÎã¨ÌïòÎäî PendingIntentÏóêÏÑú ÏàòÏ†ïÌï† Ïàò ÏóÜÎèÑÎ°ù Ìï©ÎãàÎã§.

  NotificationManagerCompat.notify()Î•º Ìò∏Ï∂úÌïú ÌõÑÏóêÎäî ÎÅùÏûÖÎãàÎã§. ÏãúÏä§ÌÖúÏùÄ ÏïåÎ¶ºÏùÑ ÌëúÏãúÌïòÍ≥†, ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÅ¥Î¶≠Ìï† Îïå PendingIntent.send()Î•º Ìò∏Ï∂úÌïòÏó¨ Ïï±ÏùÑ ÏãúÏûëÌï©ÎãàÎã§.

  ### immutable PendingIntent ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ∏∞
  ÎßåÏïΩ Ïï±Ïù¥ PendingIntentÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï¥Ïïº ÌïúÎã§Î©¥, Í∞ÄÎ≥Ä(mutability) PendingIntentÏó¨Ïïº Ìï† Í≤ÉÏù¥ÎùºÍ≥† ÏÉùÍ∞ÅÌï† Ïàò ÏûàÏßÄÎßå, Ìï≠ÏÉÅ Í∑∏Î†áÏßÄÎäî ÏïäÏäµÎãàÎã§! PendingIntentÎ•º ÏÉùÏÑ±Ìïú Ïï±ÏùÄ Ìï≠ÏÉÅ FLAG_UPDATE_CURRENT ÌîåÎûòÍ∑∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.

  ```kotlin
  val updatedIntent = Intent(applicationContext, MainActivity::class.java).apply {
     action = NOTIFICATION_ACTION
     data = differentDeepLink
  }
  // FLAG_UPDATE_CURRENTÎ•º ÏÇ¨Ïö©ÌïòÍ∏∞ ÎïåÎ¨∏Ïóê
  // Ïù¥Î°ú Ïù∏Ìï¥ Í∏∞Ï°¥ PendingIntentÍ∞Ä ÏúÑÏóêÏÑú ÏàòÏ†ïÌïú ÎÇ¥Ïö©ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Îê©ÎãàÎã§.
  val updatedPendingIntent = PendingIntent.getActivity(
     applicationContext,
     NOTIFICATION_REQUEST_CODE,
     updatedIntent,
     PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
  )
  // PendingIntentÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.
  ```

  ### Inter-app APIs
  ÏùºÎ∞òÏ†ÅÏúºÎ°ú startActivityForResult()ÏôÄ onActivityResult()Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÎèôÏûëÏùÑ ÏàòÌñâÌïú ÌõÑÏóê ÏΩúÎ∞±ÏùÑ Î∞õÏßÄÎßå, Ïù¥Í≤ÉÎßåÏù¥ Ïú†ÏùºÌïú Î∞©Î≤ïÏùÄ ÏïÑÎãôÎãàÎã§.

  Ïò®ÎùºÏù∏ Ï£ºÎ¨∏ Ïï±ÏùÑ ÏÉÅÏÉÅÌï¥Î≥¥ÏÑ∏Ïöî. Ïù¥ Ïï±ÏùÄ Îã§Î•∏ Ïï±Îì§Ïù¥ Ïù¥ÏôÄ ÌÜµÌï©ÌïòÍ∏∞ ÏúÑÌï¥ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî APIÎ•º Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§. Ï£ºÎ¨∏ Ïï±ÏùÄ ÏùåÏãù Ï£ºÎ¨∏ ÌîÑÎ°úÏÑ∏Ïä§Î•º ÏãúÏûëÌïòÎäî Îç∞ ÏÇ¨Ïö©ÎêòÎäî ÏûêÏã†Ïùò IntentÏùò extraÎ°ú PendingIntentÎ•º ÏàòÏã†Ìï† Ïàò ÏûàÏùÑ Í≤ÉÏûÖÎãàÎã§. Ï£ºÎ¨∏ Ïï±ÏùÄ Ï£ºÎ¨∏Ïù¥ ÏôÑÎ£åÎêú ÌõÑÏóêÏïº PendingIntentÎ•º ÏãúÏûëÌï©ÎãàÎã§.

  Ïù¥ Í≤ΩÏö∞, Ï£ºÎ¨∏ Ïï±ÏùÄ startActivityForResult() ÎåÄÏã† PendingIntentÎ•º ÏÇ¨Ïö©ÌïòÎØÄÎ°ú Ï£ºÎ¨∏Ïù¥ ÏôÑÎ£åÎêòÎäî Îç∞Ïóê ÏÉÅÎãπÌïú ÏãúÍ∞ÑÏù¥ Í±∏Î¶¥ Ïàò ÏûàÏúºÎ©∞, Ïù¥ ÏãúÍ∞Ñ ÎèôÏïà ÏÇ¨Ïö©ÏûêÍ∞Ä Í∏∞Îã§Î¶¨ÎèÑÎ°ù ÌïòÎäî Í≤ÉÏùÄ Ìï©Î¶¨Ï†ÅÏù¥ÏßÄ ÏïäÏäµÎãàÎã§.

  Ïö∞Î¶¨Îäî Î∂àÎ≥Ä(immutable) PendingIntentÎ•º ÏÉùÏÑ±ÌïòÎ†§Í≥† Ìï©ÎãàÎã§. Ïô∏Î∂ÄÏùò Ï£ºÎ¨∏ Ïï±Ïù¥ Ïö∞Î¶¨Ïùò IntentÏóê ÎåÄÌï¥ ÏïÑÎ¨¥Îü∞ Î≥ÄÍ≤ΩÎèÑ Í∞ÄÌïòÏßÄ ÏïäÍ∏∞Î•º ÏõêÌï©ÎãàÎã§. Ï£ºÎ¨∏Ïù¥ ÎèÑÏ∞©Ìïú Í∑∏ÎåÄÎ°ú Î≥¥ÎÇ¥Í∏∞Îßå ÌïòÎ©¥ Îê©ÎãàÎã§.

  ### Í∞ÄÎ≥Ä(mutability) PendingIntent
  Í∑∏Îü¨ÎÇò Ï£ºÎ¨∏ Ïï±Ïùò Í∞úÎ∞úÏûêÎùºÎ©¥, Ìò∏Ï∂úÌïú Ïï±ÏúºÎ°ú ÎèåÏïÑÍ∞à Îïå "ÌîºÏûê ÏãúÍ∞ÑÏûÖÎãàÎã§!"ÏôÄ Í∞ôÏùÄ Î©îÏãúÏßÄÎ•º ÏûÖÎ†•Ìï† Ïàò ÏûàÎäî Í∏∞Îä•ÏùÑ Ï∂îÍ∞ÄÌïòÍ≥† Ïã∂ÏùÑ Ïàò ÏûàÏäµÎãàÎã§. Ïù¥ Í≤ΩÏö∞ Í∞ÄÎ≥Ä(mutability) PendingIntentÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.

  PendingIntentÎäî ÏÇ¨Ïã§ÏÉÅ IntentÎ•º ÎûòÌïëÌïú Í≤ÉÏù¥ÎØÄÎ°ú, PendingIntent.getIntent()ÎùºÎäî Î©îÏÑúÎìúÎ•º Ìò∏Ï∂úÌïòÏó¨ ÎûòÌïëÎêú IntentÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÎã§Í≥† ÏÉùÍ∞ÅÌï† Ïàò ÏûàÏäµÎãàÎã§. Í∑∏Îü¨ÎÇò Í∑∏Î†áÏßÄ ÏïäÏäµÎãàÎã§. Í∑∏Î†áÎã§Î©¥ Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäî Í±∏ÍπåÏöî?

  PendingIntentÏùò send() Î©îÏÑúÎìúÏóêÎäî Îß§Í∞úÎ≥ÄÏàò ÏóÜÏù¥ Ìò∏Ï∂úÎêòÎäî Î©îÏÑúÎìú Ïô∏ÏóêÎèÑ, IntentÎ•º Îß§Í∞úÎ≥ÄÏàòÎ°ú ÏÇ¨Ïö©ÌïòÎäî Îã§Î•∏ Î™á Í∞ÄÏßÄ Î≤ÑÏ†ÑÏù¥ ÏûàÏäµÎãàÎã§.

  ```kotlin
  fun PendingIntent.send(
      context: Context!, 
      code: Int, 
      intent: Intent?
  )
  ```

  Ïù¥ intent Îß§Í∞úÎ≥ÄÏàòÎäî PendingIntentÏóê Ìè¨Ìï®Îêú IntentÎ•º ÎåÄÏ≤¥ÌïòÏßÄ ÏïäÍ≥†, PendingIntentÍ∞Ä ÏÉùÏÑ±Îê† Îïå Ï†úÍ≥µÎêòÏßÄ ÏïäÏùÄ wrapped IntentÏùò Îß§Í∞úÎ≥ÄÏàòÎ•º Ï±ÑÏö∞Îäî Îç∞ ÏÇ¨Ïö©Îê©ÎãàÎã§.

  Îã§Ïùå ÏòàÎ•º ÏÇ¥Ìé¥Î≥¥Í≤†ÏäµÎãàÎã§.

  ```kotlin
  val orderDeliveredIntent = Intent(applicationContext, OrderDeliveredActivity::class.java).apply {
     action = ACTION_ORDER_DELIVERED
  }
  val mutablePendingIntent = PendingIntent.getActivity(
     applicationContext,
     NOTIFICATION_REQUEST_CODE,
     orderDeliveredIntent,
     PendingIntent.FLAG_MUTABLE
  )
  ```

  Ïù¥ PendingIntentÎ•º Ïò®ÎùºÏù∏ Ï£ºÎ¨∏ Ïï±Ïóê Ï†ÑÎã¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. Î∞∞ÏÜ°Ïù¥ ÏôÑÎ£åÎêú ÌõÑ, Ï£ºÎ¨∏ Ïï±ÏùÄ customerMessageÎ•º Í∞ÄÏ†∏ÏôÄ Îã§ÏùåÍ≥º Í∞ôÏù¥ intent extraÎ°ú Ï†ÑÏÜ°Ìï† Ïàò ÏûàÏäµÎãàÎã§.

  ```kotlin
  val intentWithExtrasToFill = Intent().apply {
     putExtra(EXTRA_CUSTOMER_MESSAGE, customerMessage)
  }
  mutablePendingIntent.send(
     applicationContext,
     PENDING_INTENT_CODE,
     intentWithExtrasToFill
  )
  ```

  Ìò∏Ï∂úÌïòÎäî Ïï±ÏùÄ Í∑∏ IntentÏóêÏÑú extraÏù∏ EXTRA_CUSTOMER_MESSAGEÎ•º Î≥º Ïàò ÏûàÍ≥†, Ìï¥Îãπ Î©îÏãúÏßÄÎ•º ÌëúÏãúÌï† Ïàò ÏûàÍ≤å Îê† Í≤ÉÏûÖÎãàÎã§.

  ### PendingIntent Í∞ÄÎ≥ÄÏÑ± ÏÑ†Ïñ∏ Ïãú Í≥†Î†§ÏÇ¨Ìï≠
  ‚ö†Ô∏è Í∞ÄÎ≥Ä(mutability) PendingIntentÎ•º ÏÉùÏÑ±Ìï† ÎïåÎäî Î∞òÎìúÏãú ÏãúÏûëÎê† Ïª¥Ìè¨ÎÑåÌä∏(component)Î•º Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÌï¥Ïïº Ìï©ÎãàÎã§. ÏúÑÏóêÏÑúÏ≤òÎüº Ï†ïÌôïÌïú ÌÅ¥ÎûòÏä§Î•º ÏßÅÏ†ë ÏÑ§Ï†ïÌïòÎäî Î∞©Î≤ïÏúºÎ°ú Ìï† ÏàòÎèÑ ÏûàÏßÄÎßå, Intent.setComponent()Î•º Ìò∏Ï∂úÌïòÎäî Î∞©Î≤ïÏúºÎ°úÎèÑ ÏÑ§Ï†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.

  Ïï±ÏóêÏÑú Intent.setPackage()Î•º Ìò∏Ï∂úÌïòÎäî Í≤ÉÏù¥ Îçî Í∞ÑÎã®ÌïòÎã§Í≥† ÏÉùÍ∞ÅÎê† Ïàò ÏûàÏùÑ Í≤ÉÏûÖÎãàÎã§. Í∑∏Îü¨ÎÇò Ïù¥Î†áÍ≤å ÌïòÎ©¥ Ïó¨Îü¨ Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÏùºÏπòÌï† Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÏúºÎØÄÎ°ú Îß§Ïö∞ Ï£ºÏùòÌï¥Ïïº Ìï©ÎãàÎã§. Í∞ÄÎä•ÌïòÎ©¥ ÌäπÏ†ï Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä IntentÎ•º ÏàòÏã†ÌïòÎèÑÎ°ù ÏßÄÏ†ïÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§.

  ‚ö†Ô∏è FLAG_IMMUTABLE ÌîåÎûòÍ∑∏Î°ú ÏÉùÏÑ±Îêú PendingIntentÏùò Í∞íÏùÑ Ïû¨Ï†ïÏùòÌïòÎ†§Í≥† ÏãúÎèÑÌïòÎ©¥, Î≥ÄÍ≤ΩÎêòÏßÄ ÏïäÏùÄ ÏõêÎûò wrapped IntentÍ∞Ä Ï†ÑÎã¨ÎêòÎäî silent failureÍ∞Ä Î∞úÏÉùÌï©ÎãàÎã§.

  Î∂àÎ≥Ä PendingIntentÎäî ÏûêÏ≤¥ PendingIntentÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. Îã§Î•∏ Ïï±Ïù¥ Î¨¥Ïñ∏Í∞ÄÎ•º Î≥ÄÍ≤ΩÌï¥Ïïº ÌïòÎäî Í≤ΩÏö∞ÏóêÎßå PendingIntentÎ•º Í∞ÄÎ≥Ä(mutability)ÏúºÎ°ú ÎßåÎì§Ïñ¥Ïïº Ìï©ÎãàÎã§.

  ### ÌîåÎûòÍ∑∏Ïóê ÎåÄÌïú ÏûêÏÑ∏Ìïú ÎÇ¥Ïö©
  Ìå¨Îî©Ïù∏ÌÖêÌä∏(PendingIntent)Î•º ÏÉùÏÑ±Ìï† Îïå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî Î™á Í∞ÄÏßÄ ÌîåÎûòÍ∑∏Ïóê ÎåÄÌï¥ Ïù¥ÏïºÍ∏∞ÌñàÏßÄÎßå, Ï∂îÍ∞ÄÎ°ú Îã§Î£∞ ÌîåÎûòÍ∑∏Í∞Ä ÏûàÏäµÎãàÎã§.

  FLAG_IMMUTABLE: Ìå¨Îî©Ïù∏ÌÖêÌä∏ ÎÇ¥Î∂ÄÏùò Ïù∏ÌÖêÌä∏Îäî PendingIntent.send()Ïóê Ïù∏ÌÖêÌä∏Î•º Ï†ÑÎã¨ÌïòÎäî Îã§Î•∏ Ïï±ÏóêÏÑú ÏàòÏ†ïÌï† Ïàò ÏóÜÏùåÏùÑ ÎÇòÌÉÄÎÉÖÎãàÎã§. Ïï±ÏùÄ ÏûêÏ≤¥ Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º ÏàòÏ†ïÌïòÍ∏∞ ÏúÑÌï¥ Ìï≠ÏÉÅ FLAG_UPDATE_CURRENTÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.

  Android 12 Ïù¥Ï†ÑÏóêÎäî Ïù¥ ÌîåÎûòÍ∑∏ ÏóÜÏù¥ ÏÉùÏÑ±Îêú Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í∞ÄÎ≥Ä(mutable)ÌñàÏäµÎãàÎã§.

  ‚ö†Ô∏è Android 6(API 23) Ïù¥Ï†ÑÏùò ÏïàÎìúÎ°úÏù¥Îìú Î≤ÑÏ†ÑÏóêÏÑúÎäî Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä Ìï≠ÏÉÅ Í∞ÄÎ≥Ä(mutable)ÌñàÏäµÎãàÎã§.

  üÜï FLAG_MUTABLE: Ìå¨Îî©Ïù∏ÌÖêÌä∏ ÎÇ¥Î∂ÄÏùò Ïù∏ÌÖêÌä∏Îäî PendingIntent.send()Ïùò Ïù∏ÌÖêÌä∏ Îß§Í∞úÎ≥ÄÏàòÏùò Í∞íÍ≥º Î≥ëÌï©ÌïòÏó¨ Ïï±Ïóê ÏùòÌï¥ ÏóÖÎç∞Ïù¥Ìä∏Îê† Ïàò ÏûàÎèÑÎ°ù ÌóàÏö©Ìï®ÏùÑ ÎÇòÌÉÄÎÉÖÎãàÎã§.

  ‚ö†Ô∏è Í∞ÄÎ≥Ä(mutable)Ïù∏ Ìå¨Îî©Ïù∏ÌÖêÌä∏Ïùò Í≤ΩÏö∞ Ìï≠ÏÉÅ ÎûòÌïëÎêú Ïù∏ÌÖêÌä∏Ïùò ComponentNameÏùÑ Ï±ÑÏõåÏïº Ìï©ÎãàÎã§. Ïù¥Î•º ÎÜìÏπòÎ©¥ Î≥¥Ïïà Ï∑®ÏïΩÏ†êÏù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏäµÎãàÎã§!

  Ïù¥ ÌîåÎûòÍ∑∏Îäî Android 12Ïóê Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§. Android 12 Ïù¥Ï†ÑÏóêÎäî FLAG_IMMUTABLE ÌîåÎûòÍ∑∏ ÏóÜÏù¥ ÏÉùÏÑ±Îêú Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî ÏïîÏãúÏ†ÅÏúºÎ°ú Í∞ÄÎ≥Ä(mutable)ÌñàÏäµÎãàÎã§.

  FLAG_UPDATE_CURRENT: Í∏∞Ï°¥Ïùò Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º ÏÉàÎ°úÏö¥ Ï∂îÍ∞Ä Îç∞Ïù¥ÌÑ∞Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎèÑÎ°ù ÏãúÏä§ÌÖúÏóê ÏöîÏ≤≠Ìï©ÎãàÎã§. ÏÉàÎ°úÏö¥ Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Ï†ÄÏû•ÌïòÎäî ÎåÄÏã† Í∏∞Ï°¥Ïùò Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§. Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä Îì±Î°ùÎêòÏñ¥ ÏûàÏßÄ ÏïäÏùÄ Í≤ΩÏö∞, Ïù¥ ÌîåÎûòÍ∑∏Í∞Ä ÏûàÎäî Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä Îì±Î°ùÎê©ÎãàÎã§.

  FLAG_ONE_SHOT: Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Ìïú Î≤àÎßå Ï†ÑÏÜ°(PendingIntent.send())Ìï† Ïàò ÏûàÎèÑÎ°ù ÌóàÏö©Ìï©ÎãàÎã§. Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Îã§Î•∏ Ïï±Ïóê Ï†ÑÎã¨Ìï† Îïå, Ìï¥Îãπ Ìå¨Îî©Ïù∏ÌÖêÌä∏ ÎÇ¥Î∂ÄÏùò Ïù∏ÌÖêÌä∏Í∞Ä Ìïú Î≤àÎßå Ï†ÑÏÜ°ÎêòÏñ¥Ïïº ÌïòÎäî Í≤ΩÏö∞Ïóê Ï§ëÏöîÌï©ÎãàÎã§. Ïù¥Îäî Ìé∏ÏùòÏÑ±Í≥º Ìï®Íªò Ïï±Ïù¥ ÌäπÏ†ï ÎèôÏûëÏùÑ Ïó¨Îü¨ Î≤à ÏàòÌñâÌïòÎäî Í≤ÉÏùÑ Î∞©ÏßÄÌïòÎäî Îç∞ ÏÇ¨Ïö©Îê† Ïàò ÏûàÏäµÎãàÎã§.

  üîê FLAG_ONE_SHOTÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ "Ïû¨Ï†ÑÏÜ° Í≥µÍ≤©(replay attacks)"Í≥º Í∞ôÏùÄ Î¨∏Ï†úÎ•º Î∞©ÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.

  FLAG_CANCEL_CURRENT: Ï°¥Ïû¨ÌïòÎäî Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä ÏûàÎã§Î©¥ Ïù¥Î•º Ï∑®ÏÜåÌïú ÌõÑ ÏÉàÎ°úÏö¥ Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Îì±Î°ùÌï©ÎãàÎã§. ÌäπÏ†ï Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä Ìïú Ïï±Ïóê Ï†ÑÏÜ°ÎêòÏóàÍ≥†, Ïù¥Î•º Îã§Î•∏ Ïï±Ïóê Ï†ÑÏÜ°ÌïòÍ≥† Îç∞Ïù¥ÌÑ∞Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎ†§Îäî Í≤ΩÏö∞Ïóê Ï§ëÏöîÌï©ÎãàÎã§. FLAG_CANCEL_CURRENTÎ•º ÏÇ¨Ïö©ÌïòÎ©¥ Ï≤´ Î≤àÏß∏ Ïï±ÏùÄ Îçî Ïù¥ÏÉÅ Ìï¥Îãπ Ìå¨Îî©Ïù∏ÌÖêÌä∏Ïóê ÎåÄÌï¥ sendÎ•º Ìò∏Ï∂úÌï† Ïàò ÏóÜÏßÄÎßå, Îëê Î≤àÏß∏ Ïï±ÏùÄ Ìò∏Ï∂úÌï† Ïàò ÏûàÏäµÎãàÎã§.

  ### Ìå¨Îî©Ïù∏ÌÖêÌä∏ ÏàòÏã†
  ÏãúÏä§ÌÖúÏù¥ÎÇò Îã§Î•∏ ÌîÑÎ†àÏûÑÏõåÌÅ¨ÏóêÏÑú API Ìò∏Ï∂úÏùò Î∞òÌôò Í∞íÏúºÎ°ú Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Ï†úÍ≥µÌïòÎäî Í≤ΩÏö∞Í∞Ä ÏûàÏäµÎãàÎã§. Android 11ÏóêÏÑú Ï∂îÍ∞ÄÎêú MediaStore.createWriteRequest() Î©îÏÑúÎìúÍ∞Ä Í∑∏ ÏòàÏûÖÎãàÎã§.

    ```kotlin
    static fun MediaStore.createWriteRequest(
        resolver: ContentResolver, 
        uris: MutableCollection<Uri>
    ): PendingIntent
    ```
  Ïï±Ïù¥ ÏÉùÏÑ±Ìïú Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî Ïï±Ïùò ÏãùÎ≥ÑÏûêÎ°ú Ïã§ÌñâÎêòÎäî Í≤ÉÏ≤òÎüº, ÏãúÏä§ÌÖúÏù¥ ÏÉùÏÑ±Ìïú Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî ÏãúÏä§ÌÖúÏùò ÏãùÎ≥ÑÏûêÎ°ú Ïã§ÌñâÎê©ÎãàÎã§. Ïù¥ APIÏùò Í≤ΩÏö∞, Ïï±ÏùÄ Ìï¥Îãπ Ïï±Ïóê ÎåÄÌï¥ ÏùºÍ¥ÑÏ†ÅÏúºÎ°ú Ïó¨Îü¨ URIÏóê ÎåÄÌïú Ïì∞Í∏∞ Í∂åÌïúÏùÑ Î∂ÄÏó¨Ìï† Ïàò ÏûàÎäî Ïï°Ìã∞ÎπÑÌã∞Î•º ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.

  ### ÏöîÏïΩ
  Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî Ïï±Ïù¥ Ïñ¥Îñ§ ÏãúÏ†êÏóêÏÑú ÎÇòÏ§ëÏóê Ïï±ÏúºÎ°úÏÑú ÏãúÏûëÌï† Ïàò ÏûàÎèÑÎ°ù ÏãúÏä§ÌÖúÏù¥ÎÇò Îã§Î•∏ Ïï±Ïù¥ ÏÉùÏÑ±Ìïú Ïù∏ÌÖêÌä∏Î•º ÎûòÌïëÌïòÎäî Í≤ÉÏúºÎ°ú ÏÉùÍ∞ÅÌï† Ïàò ÏûàÏäµÎãàÎã§.

  ÎòêÌïú, Ìå¨Îî©Ïù∏ÌÖêÌä∏Îäî ÏùºÎ∞òÏ†ÅÏúºÎ°ú Î∂àÎ≥Ä(immutable)Ìï¥Ïïº ÌïòÎ©∞, Ïù¥Î•º ÌÜµÌï¥ Ïï±ÏùÄ ÏûêÏ≤¥ Ìå¨Îî©Ïù∏ÌÖêÌä∏ Í∞ùÏ≤¥Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎäî Í≤ÉÏùÑ Î∞©ÏßÄÌïòÏßÄ ÏïäÏäµÎãàÎã§. Ïï±ÏùÄ FLAG_UPDATE_CURRENT ÌîåÎûòÍ∑∏ÏôÄ FLAG_IMMUTABLEÏóê Ï∂îÍ∞ÄÌïòÏó¨ ÏûêÏ≤¥ Ìå¨Îî©Ïù∏ÌÖêÌä∏ Í∞ùÏ≤¥Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.

  Ìå¨Îî©Ïù∏ÌÖêÌä∏Í∞Ä Í∞ÄÎ≥Ä(mutable)Ìï¥Ïïº ÌïòÎäî Í≤ΩÏö∞ÏóêÎäî ÎûòÌïëÎêú Ïù∏ÌÖêÌä∏Ïùò ComponentNameÏùÑ Ï±ÑÏö∞Îäî Îì±Ïùò Ï£ºÏùòÏÇ¨Ìï≠Ïù¥ ÏûàÏäµÎãàÎã§.

  ÎßàÏßÄÎßâÏúºÎ°ú, ÏãúÏä§ÌÖúÏù¥ÎÇò ÌîÑÎ†àÏûÑÏõåÌÅ¨Í∞Ä Ìå¨Îî©Ïù∏ÌÖêÌä∏Î•º Ïï±Ïóê Ï†úÍ≥µÌïòÏó¨ Ïã§ÌñâÌï† ÎïåÏôÄ Ïã§Ìñâ ÌÉÄÏù¥Î∞çÏùÑ Í≤∞Ï†ïÌï† Ïàò ÏûàÎèÑÎ°ù ÌïòÎäî Í≤ΩÏö∞Í∞Ä ÏûàÏäµÎãàÎã§.

  Ìå¨Îî©Ïù∏ÌÖêÌä∏Ïóê ÎåÄÌïú ÏóÖÎç∞Ïù¥Ìä∏Îäî Android 12ÏóêÏÑú Ïï± Î≥¥ÏïàÏùÑ Í∞úÏÑ†ÌïòÍ∏∞ ÏúÑÌï¥ ÏàòÌñâÎêú Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Ï§ë ÌïòÎÇòÏûÖÎãàÎã§. ÎØ∏Î¶¨Î≥¥Í∏∞ÏóêÏÑúÏùò Î™®Îì† Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïóê ÎåÄÌï¥ Ïó¨Í∏∞ÏóêÏÑú ÏùΩÏñ¥Î≥º Ïàò ÏûàÏäµÎãàÎã§.

  Îçî ÎßéÏùÄ ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÍ≥† Ïã∂ÏúºÏã†Í∞ÄÏöî? ÏÉàÎ°úÏö¥ OS Í∞úÎ∞úÏûê ÎØ∏Î¶¨Î≥¥Í∏∞ÏóêÏÑú Ïï±ÏùÑ ÌÖåÏä§Ìä∏ÌïòÍ≥† Í≤ΩÌóòÏóê ÎåÄÌïú ÌîºÎìúÎ∞±ÏùÑ Ï†úÍ≥µÌïòÎäî Í≤ÉÏùÑ Í∂åÏû•Ìï©ÎãàÎã§!
